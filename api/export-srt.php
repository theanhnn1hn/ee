<?php
/**
 * SRT Export API
 * Export generated audio as SRT subtitles (matches Python tool)
 */

require_once '../config.php';

requireLogin();

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    echo json_encode(['success' => false, 'message' => 'Method not allowed']);
    exit;
}

$input = json_decode(file_get_contents('php://input'), true);

if (!isset($input['generation_id']) || empty($input['generation_id'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing generation_id']);
    exit;
}

$generationId = $input['generation_id'];

try {
    // Get generation record
    $stmt = $db->prepare("
        SELECT gh.*, v.name as voice_name, uv.custom_name
        FROM generation_history gh
        LEFT JOIN voices v ON v.voice_id = gh.voice_id
        LEFT JOIN user_voices uv ON uv.voice_id = gh.voice_id AND uv.user_id = gh.user_id
        WHERE gh.id = ? AND gh.user_id = ? AND gh.status = 'completed'
    ");
    
    $stmt->execute([$generationId, $_SESSION['user_id']]);
    $generation = $stmt->fetch();
    
    if (!$generation) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Generation not found or not completed']);
        exit;
    }
    
    // Load sentence data
    $sentenceDataFile = TEMP_PATH . "sentences_{$generationId}.json";
    
    if (!file_exists($sentenceDataFile)) {
        // If no sentence data file, create simple SRT from the text
        $srtContent = createSimpleSRT($generation);
    } else {
        // Load stored sentence data (matches Python tool)
        $sentenceDataJson = file_get_contents($sentenceDataFile);
        $sentenceData = json_decode($sentenceDataJson, true);
        
        if (!$sentenceData || !isset($sentenceData['sentences'])) {
            // Fallback to simple SRT
            $srtContent = createSimpleSRT($generation);
        } else {
            // Create SRT from sentence timing data (matches Python tool)
            $srtContent = createTimedSRT($sentenceData, $generation);
        }
    }
    
    // Generate filename
    $voiceName = cleanFilename($generation['custom_name'] ?: $generation['voice_name'] ?: 'Generated');
    $timestamp = date('Y-m-d_H-i-s', strtotime($generation['created_at']));
    $filename = "{$voiceName}_subtitles_{$timestamp}.srt";
    
    // Set headers for file download
    header('Content-Type: application/x-subrip');
    header('Content-Disposition: attachment; filename="' . $filename . '"');
    header('Content-Length: ' . strlen($srtContent));
    header('Cache-Control: no-cache, must-revalidate');
    
    // Log export activity
    logActivity('srt_export', [
        'generation_id' => $generationId,
        'voice_name' => $generation['voice_name'],
        'filename' => $filename
    ]);
    
    // Output SRT content
    echo $srtContent;
    
} catch (Exception $e) {
    http_response_code(500);
    header('Content-Type: application/json');
    echo json_encode([
        'success' => false,
        'message' => 'SRT export failed: ' . $e->getMessage()
    ]);
    
    logActivity('srt_export_failed', [
        'generation_id' => $generationId,
        'error' => $e->getMessage()
    ]);
}

/**
 * Create SRT from sentence timing data (matches Python tool)
 */
function createTimedSRT($sentenceData, $generation) {
    $srtLines = [];
    
    // Add metadata comments (matches Python tool)
    $voiceName = $generation['custom_name'] ?: $generation['voice_name'] ?: 'Unknown';
    $srtLines[] = "<!-- Generated by ElevenLabs Professional Studio -->";
    $srtLines[] = "<!-- Export Date: " . date('Y-m-d H:i:s') . " -->";
    $srtLines[] = "<!-- Voice: " . $voiceName . " -->";
    $srtLines[] = "<!-- Sentences: " . count($sentenceData['sentences']) . " -->";
    $srtLines[] = "";
    
    // Generate SRT entries
    foreach ($sentenceData['sentences'] as $index => $sentence) {
        $sequence = $index + 1;
        $startTime = secondsToSRTTime($sentence['start_time']);
        $endTime = secondsToSRTTime($sentence['end_time']);
        $text = trim($sentence['text']);
        
        $srtLines[] = $sequence;
        $srtLines[] = "$startTime --> $endTime";
        $srtLines[] = $text;
        $srtLines[] = "";
    }
    
    return implode("\n", $srtLines);
}

/**
 * Create simple SRT when no timing data available
 */
function createSimpleSRT($generation) {
    $srtLines = [];
    
    // Add metadata
    $voiceName = $generation['custom_name'] ?: $generation['voice_name'] ?: 'Unknown';
    $srtLines[] = "<!-- Generated by ElevenLabs Professional Studio -->";
    $srtLines[] = "<!-- Export Date: " . date('Y-m-d H:i:s') . " -->";
    $srtLines[] = "<!-- Voice: " . $voiceName . " -->";
    $srtLines[] = "<!-- Note: Estimated timing (no sentence data available) -->";
    $srtLines[] = "";
    
    // Split text into sentences for basic SRT
    $text = $generation['text_input'];
    $sentences = splitIntoSentences($text);
    
    // Estimate timing based on audio duration
    $totalDuration = $generation['audio_duration'] ?: estimateDurationFromText($text);
    $timePerSentence = $totalDuration / count($sentences);
    
    foreach ($sentences as $index => $sentence) {
        $sequence = $index + 1;
        $startTime = $index * $timePerSentence;
        $endTime = ($index + 1) * $timePerSentence;
        
        $srtLines[] = $sequence;
        $srtLines[] = secondsToSRTTime($startTime) . " --> " . secondsToSRTTime($endTime);
        $srtLines[] = trim($sentence);
        $srtLines[] = "";
    }
    
    return implode("\n", $srtLines);
}

/**
 * Convert seconds to SRT time format (HH:MM:SS,mmm)
 */
function secondsToSRTTime($seconds) {
    $hours = floor($seconds / 3600);
    $minutes = floor(($seconds % 3600) / 60);
    $secs = floor($seconds % 60);
    $milliseconds = floor(($seconds - floor($seconds)) * 1000);
    
    return sprintf("%02d:%02d:%02d,%03d", $hours, $minutes, $secs, $milliseconds);
}

/**
 * Split text into sentences
 */
function splitIntoSentences($text) {
    // Simple sentence splitting
    $sentences = preg_split('/[.!?]+\s+/', $text, -1, PREG_SPLIT_NO_EMPTY);
    
    // Filter out very short sentences
    $sentences = array_filter($sentences, function($sentence) {
        return strlen(trim($sentence)) > 3;
    });
    
    return array_values($sentences);
}

/**
 * Estimate duration from text length
 */
function estimateDurationFromText($text) {
    $wordCount = str_word_count($text);
    // Estimate 150 words per minute average speaking rate
    return ($wordCount / 150) * 60;
}

?>
